'''
                   *** Инкапсуляция***
Определение: Инкапсуляция — это механизм, который ограничивает доступ к внутренним данным объекта и защищает его состояние, предоставляя методы для взаимодействия с этими данными.

Зачем это нужно:

Защита данных: Скрытие внутреннего состояния объекта помогает предотвратить его некорректное изменение.
Упрощение интерфейса: Пользователи объекта взаимодействуют только с его публичными методами, что упрощает использование.'''
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Приватное свойство

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance

'''
                                   ***Полиморфизм
Определение: Полиморфизм позволяет объектам разных классов обрабатывать одно и то же сообщение (вызов метода) по-разному.

Зачем это нужно:
Гибкость: Вы можете использовать один интерфейс для работы с различными объектами, что упрощает код.
Расширяемость: Легко добавлять новые классы, не изменяя существующий код.'''
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"
def animal_sound(animal):
    print(animal.speak())

animal_sound(Dog())  # Вывод: Woof!
animal_sound(Cat())  # Вывод: Meow!

'''Абстракция
Определение: Абстракция позволяет скрыть сложность системы, предоставляя только необходимые детали.

Зачем это нужно:
Упрощение: Пользователи работают с высокоуровневыми интерфейсами, не погружаясь в детали реализации.
Управление сложностью: Позволяет сосредоточиться на взаимодействии между объектами.'''
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2
    
'''
                                           ***Наследование***
Определение: Наследование позволяет создавать новые классы на основе существующих, унаследуя их свойства и методы.

Зачем это нужно:
Повторное использование кода: Снижает дублирование кода, позволяя использовать общие методы и свойства.
Упрощение расширения: Легко добавлять новые функциональности, создавая подклассы.'''   
class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

dog = Dog()
print(dog.speak())  # Вывод: Woof!

'''Понимание этих концепций является критически важным для эффективного программирования на Python и других языках, так как они помогают создавать более организованный, читаемый и поддерживаемый код. ООП позволяет разработчикам моделировать реальные объекты и их взаимодействия, что значительно упрощает процесс разработки сложных систем.'''

