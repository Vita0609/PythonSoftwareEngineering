'''
                            ***Работа с файлами***
Когда приложение завершает свою работу, результат его работы, который хранился в переменных в приложении, будет потерян. Оперативная память, принадлежащая приложению, будет очищена и результат работы потерян. Часто нам необходимо сохранять результат работы, чтобы позже вернуться к нему. Самый простой способ сохранить полезную информацию – это записать ее в файл на диск. Python предоставляет функционал работы с любыми файлами.

У Python есть абстракция над файлами – это указатель на файл или файловый объект. Ничего сложного в этом нет, это наоборот упрощает работу со многими системными ресурсами.

Файловый объект – это системный ресурс, доступ к которому предоставляет операционная система. Обычно файловый объект можно открыть (получить/создать), закрыть (сообщить системе, что работа с ним завершена), можно записать в него что-то и прочесть что-то.

Непосредственная работа с файлами в Python начинается с открытия файла или получения от системы доступа к файлу, получения того же файлового объекта. Для этого есть встроенная функция open, в которую нужно обязательно передать имя файла, который мы хотим открыть, и можно указать, как именно мы хотим открыть файл:'''
fh = open('test_file.txt')
# В этом примере fh – это файловый объект, через который мы можем работать с файлом.

'''После завершения работы с файлом необходимо вернуть ресурс (файл) системе. Для этого у файлового объекта нужно вызвать метод close:'''
fh = open('test.txt')
# операції над файлом
fh.close()
'''Закрывать файл обязательно. Незакрытые файлы могут стать причиной множества неочевидных проблем и сложностей. Самый простой случай – это испорченный файл и полностью потерянная информация, которая в нем могла содержаться.

Кроме того, следует помнить, что поскольку файловый объект — это ресурс, предоставляемый операционной системой, то любое завершение работы приложения (аварийное или штатное) не означает автоматическое закрытие всех открытых фалов, что опять же может произвести к ошибкам.

Если не указать, как мы хотим открыть файл, он открывается только для считывания данных и с помощью fh можно будет только читать данные из файла. Если файла с именем test_file.txt в системе нет, вы получите исключение.

После короткого обзора, рассмотрим синтаксис функции open() более подробно. Функция open() возвращает файловый объект, который далее может быть использован для чтения или записи в файл.'''
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
'''Параметры:
file – путь к файлу в виде строки. Это может быть полный путь или путь относительно текущего каталога исполнения.
mode (необязательный) – режим, в котором будет открыт файл. Вот основные режимы, которые мы будем использовать:
'r' – чтение (по умолчанию). Файл должен существовать.
'w' – запись. Создает новый файл или перезаписывает уже существующий файл.
'a' – добавление. Дописывает в конец файла, не перезаписывая его.
'b' – бинарный режим (может быть использован вместе с другими, например 'rb' или 'wb').
'+' - обновление (чтение и запись).
buffering (необязательный) – определяет буферизацию: 0 для выключенной, 1 для включенной буферизации строк, более 1 для указания размера буфера в байтах.
encoding (необязательный) – имя кодирования, которое будет использоваться для кодирования или декодирования файла.
errors (необязательный) – указывает, как обрабатывать ошибки кодирования.
newline (необязательный) – контролирует, как обрабатываются новые строки.
closefd (необязательный) – должно быть True (по умолчанию); если указано False, файловый дескриптор не будет закрыт.
opener (необязательный) – определяет специальную функцию для открытия файла.

На самом деле, нам не нужны будут все параметры, обычно нам будет достаточно для использования первых двух.

Например, чтобы открыть файл для записи или создать новый, если его нет, или перезаписать файл, можно указать значение режима w:'''
fh = open('test.txt', 'w')
symbols_written = fh.write('hello!')
print(symbols_written) # 6
fh.close()
'''В этом примере мы создали (или перезаписали, если он уже существовал) файл test.txt для записи и записали туда строчку 'hello!' длиной 6 символов. Для записи данных в файл мы использовали метод write у объекта fh. Этот метод возвращает количество записанных в файл символов – в нашем случае число 6.

Парный метод — это метод read, который позволяет прочитать некоторое количество символов из файла.'''
fh = open('test.txt', 'w+')
fh.write('hello!')
fh.seek(0)

first_two_symbols = fh.read(2)
print(first_two_symbols)  # 'he'

fh.close()
'''В этом примере мы открыли файл в режиме чтения и записи, но сам файл мы перезаписываем, если он существует, потому что используется режим w+. Записали в файл строку 'hello!' и прочли первые два символа из файла с помощью метода read, указав в качестве аргумента двойку. Метод read возвращает прочтенные символы и поскольку мы прочитали 2 символа, то переменная first_two_symbols будет сохранять строку "he". Чтобы вернуть указатель к началу файла, мы вызвали метод seek и передали ему позицию, куда нужно переместиться 0. Чуть дальше мы рассмотрим его подробнее.

Чтобы прочитать все содержимое файла за раз можно вызвать метод read без аргументов:'''
fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
all_file = fh.read()
print(all_file)  # 'hello!'

fh.close()
# Пока файловый дескриптор не закрыт, вы можете читать с него по частям, продолжая чтение с того же места, на котором остановились:
fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
while True:
    symbol = fh.read(1)
    if len(symbol) == 0:
        break
    print(symbol)

fh.close()
# В этом примере в цикле мы считывали и выводили консоль содержимого файла по одному символу за раз. В результате вы получите в консоли, в столбик, все символы файла:
'''Еще есть удобный способ читать файл построчно, по одной строке за раз, для этого можно воспользоваться методом readline:'''
fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
while True:
    line = fh.readline()
    if not line:
        break
    print(line)

fh.close()
'''В цикле while True выполняется непрерывное чтение из файла. Метод readline() читает одну строчку из файла за раз. Если readline() возвращает пустую строку, это означает, что достигнут конец файла, поэтому цикл прерывается с помощью break. Каждая прочитанная строка выводится на экран. Поскольку readline() сохраняет символы перехода на новую строку, каждая выводимая строка будет выведена из новой строки.'''
# И аналогичный метод readlines, который читает весь файл полностью, но возвращает список строк, где элемент списка – это одна строчка из файла.
fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
lines = fh.readlines()
print(lines) # ['first line\n', 'second line\n', 'third line']
fh.close()

#Зверніть увагу, що всі методи, які читають файли порядково, залишають (не видаляють) символ перенесення рядка \n. Його, за необхідності, треба видаляти самостійно:
fh = open("test.txt", "w")
fh.write("first line\nsecond line\nthird line")
fh.close()

fh = open("test.txt", "r")
lines = [el.strip() for el in fh.readlines()]
print(lines)

fh.close()

