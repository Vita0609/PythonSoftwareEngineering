                    # Принципы сменности объектов в Python
# В Python все объекты передаются по ссылке, но важно понимать разницу между переменными (mutable) и неизменными (immutable) типами данных, ведь зависит от того, как происходит передача объектов и какие ошибки могут возникать.
# Неизменные типы в Python – это те, которые не могут быть изменены после их создания. Это включает типы, такие как целые числа int, действительные числа float, строки str, кортежи tuple.
# Когда неизменяемый объект передается в функцию, фактически передается его копия, и любые изменения этого объекта в функции не влияют на оригинальный объект.
# Рассмотрим следующий пример:
def modify_string(original: str) -> str:
    original = "змінено"
    return original

str_var = "оригінал"
print(modify_string(str_var))  # виведе: змінено
print(str_var)                # виведе: оригінал

# В этом примере даже после изменения строки в функции modify_string оригинальная переменная str_var остается неизменной.
# Сменные типы, как списки list, словари dict, множества set, могут изменяться. 
# Когда переменный объект передается в функцию, передается ссылка на этот объект, и изменения, произведенные внутри функции, отображаются на оригинальном объекте.

# Посмотрим следующий пример с переменными типами:
def modify_list(lst: list) -> None:
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3, 4]

# Здесь изменения внутри функции modify_list оказывают влияние на оригинальный список my_list. 
# Итак, мы передали в функцию modify_list наш список my_list и после выполнения функции modify_list(my_list) сам список изменился.

# Сменные объекты, передаваемые в функции, могут измениться неожиданно. 
# Это может привести к ошибкам, особенно если вы не ожидаете, что объект будет изменен.

# При "копировании" переменного объекта путем простого присвоения new_list=old_list вы копируете ссылку, а не сам объект. 
# Это означает, что изменения в одном списке будут отображаться и в другом. Фактически внутри функции modify_list состоялось присвоение lst = my_list

# Перед тем, как передавать переменные объекты, такие как списки или словари в функцию, важно учитывать, планируете ли вы изменять эти объекты в функции. 
# Если необходимо оставить оригинальный объект без изменений, рассмотрите возможность создания копии. Если вы передаете переменный объект (например, список) в функцию и модифицируете его внутри функции, оригинальный список тоже изменится.

# Используйте метод copy() для создания копий переменных объектов, если вы не хотите изменять оригинал.
def modify_list(lst: list) -> None:
    lst = lst.copy()
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3]
# Тут список my_list після виконання функції modify_list вже не зазнає змін.