'''
                               ***Продвинутая работа со строчками***
Мы уже изучили базовую работу со строчками в Python. Вы умеете создавать строки, объединять строки, менять регистр строк, проверять, что строка заканчивается или начинается некоторой последовательностью. Но возможности Python по работе со строчками не исчерпываются этим. На этом занятии мы узнаем больше о том, как работать со строками в Python, о работе с регулярными выражениями и преобразованиями строк.
Варианты создания строк
Для создания строк можно воспользоваться одинарными или двойными кавычками:'''
this_is_string = "Hi there!"
the_same_string = 'Hi there!'
this_is_string == the_same_string # True

'''Но что делать, если нам нужен текст с переносом строк (если в тексте больше одной строки)?'''
text = """This is first line
And second line
Last third line"""

song = '''Jingle bells, jingle bells
Jingle all the way
Oh, what fun it is to ride
In a one horse open sleigh'''

'''В этом примере переменная text содержит три строчки, а song — четыре строчки.
Когда интерпретатор обнаруживает повторяющиеся трижды кавычки, он воспринимает все символы к следующим трем кавычкам, которые закрывают строку, как символы строки.
Обратная ситуация, у вас есть длинная строка, которая не должна содержать переноски, но в коде ее неудобно отобразить одной строкой.'''
one_line_text = "Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points. String literals are written in a variety of ways: single quotes, double quotes, triple quoted."
'''Чтобы структурировать код и не добавлять лишних переносов, вы можете разбить одну строчную переменную на несколько частей:'''
one_line_text = "Textual data in Python is handled with str objects," \
                " or strings. Strings are immutable sequences of Unicode" \
                " code points. String literals are written in a variety " \
                " of ways: single quotes, double quotes, triple quoted."
'''Обратите внимание на символ в конце первой и второй строки кода, он указывает интерпретатору игнорировать окончание строки и продолжить сразу со следующей.
Переменная one_line_text в обоих примерах будет содержать один и тот же текст без переносов.
В Python, когда вы помещаете два строчных литерала рядом, они автоматически конкатенируются (объединяются в одну строчку). Это известно как неявная конкатенация строк:'''
("spam " "eggs") == "spam eggs"  # True
'''Выражение налево и выражение направо — две равнозначные записи одного и того же текста 'spam eggs' и, с точки зрения Python, — они неразличимы. В нашем случае, "spam" и "eggs" - это два отдельных строчных литерала, но когда они размещены друг за другом без оператора добавления (+), Python автоматически объединяет их в одну строчку.

Эта особенность часто используется для удобства, особенно при написании длинных строчек и поэтому переменную one_line_text можно записать следующим образом.'''
one_line_text = ("Textual data in Python is handled with str objects,"
                " or strings. Strings are immutable sequences of Unicode"
                " code points. String literals are written in a variety "
                " of ways: single quotes, double quotes, triple quoted.")
'''Неявная конкатенация строк – это полезная особенность языка Python, позволяющая писать более чистый и читаемый код, особенно когда работаете с длинными строками или строками, формируемыми на основе нескольких частей.

Например, в будущем, это очень помогает при создании SQL запросов в базу данных:'''
query = ("SELECT * "
         "FROM some_table "
         "WHERE condition1 = True "
         "AND condition2 = False")


'''
                                     ***Специальные символы***
Специальные символы в строках Python, известные также как экранированные символы или escape-символы, используются для представления определенных управляющих последовательностей или для включения символов, которые нельзя ввести непосредственно в строку кода.
Эти символы начинаются с обратной косой черты (backslash, \), после которой следует один или несколько символов, определяющих специальную последовательность. Это означает, что следующий за ним знак следует воспринимать как специальный символ, а не буквально.

Вот основные управляющие символы, которые необходимо знать:
\n — перенос строки
\r — возврат каретки
\t — табуляция
\f — перенос страницы
\v — вертикальная табуляция

Например, символ \n отвечает за перенос строки (line break).'''
# При выводе между словами будет символ табуляции:
print("Hello\nWorld") # Hello World 

'''Другой пример – горизонтальная табуляция \t(tab):'''
# Вывод происходит следующим образом: когда мы встречаем символ \r, то возвращаемся к началу строки и продолжаем вывод. 
# Это перезаписывает предыдущий вывод:
print("Hello my little\rsister") # sistermy little

'''Управляющий символ убой (backspace).'''
# Вывод осуществляется на один символ влево и выводит остаток после управляющего символа.
print("Hello\bWorld") # HellWorld
# Также если нам нужно выполнить выведение обратной косой черты.
print("Hello\\World") # Hello\World
'''Чтобы экранировать одинарные и двойные кавычки и разрешить использовать кавычки внутри строчных литералов.'''
'''print("He said, \"Hello\"") # It's a beautiful day'''
print("He said, \"Hello\"") # He said, "Hello
'''Эти специальные символы часто используются для форматирования текста в строках, управления выводом в консоли или терминале, а также для работы с данными в формате Unicode. Выбирайте ту форму записи, которая больше подходит под конкретную ситуацию, и руководствуйтесь удобством для записи и чтения кода, содержащего строчную переменную.'''


'''
                      ***Методы строк***
Мы уже познакомились с некоторыми методами строчек. Сейчас разберем способы, связанные с поиском в строках и созданием новейших строк.
            
            Поиск в строке
Для поиска некоторого символа или подстроки в строке можно использовать метод find:'''
s = "Hi there!"
start = 0
end = 7
print(s.find("er", start, end)) # 5
print(s.find("q")) # -1
# Этот способ возвращает индекс начала первого совпадения в строке s, начиная с позиции start к позиции end. Если start и end не указаны, поиск происходит с начала и до конца строки. Метод возвращает –1, если последовательность не найдена.

'''Еще один метод поиска подстроки в строке очень похож на find – это index. Основное отличие состоит в том, что если index не найдет подстроку, то вызовет исключение ValueError.
Если вам нужно осуществить поиск подстроки в строке справа, а не слева как в find, то для этого существует метод rfind:'''
s = 'Some words'
print(s.find("o"))
print(s.rfind('o'))
# Выражение s.find("o") вернет 1, а выражение s.rfind('o') вернет 6 ибо ищет справа строки и будет иметь следующий вывод:
'''И "правый" аналог index - rindex:'''
s = 'Some words'
print(s.index("o"))
print(s.rindex('o')) # 1 6


'''
              ***Разделение и объединение строк***
Частая ситуация, когда необходимо разбить строку на подстроки по некоему символу, например, разбить текст на предложение по символу точки и пробела после точки или предложение по словам.

             **Метод split() 
в Python используется для разбиения строки на список подстроков на основе указанного разделителя. Если разделитель не указан, по умолчанию используется пробел.
Синтаксис метода split()'''
str.split(separator=None, maxsplit=-1)
'''separator – разделитель, по которому следует разделять строку. Если не указано, строка разделяется по любому пробелу.
maxsplit – максимальное количество разделений. Значение -1 означает "без ограничений".

Рассмотрим пример'''
text = "hello world"
result = text.split()
print(result)  # Виведе: ['hello', 'world']
# В этом примере строка "hello world" разделяется на список из двух элементов: 'hello' и 'world' по пробелу.

'''Если мы хотим разделить строку указанным разделителем, то:'''
text = "apple,banana,cherry"
result = text.split(',')
print(result)  # Виведе: ['apple', 'banana', 'cherry']
'''Способ split() широко используется для обработки текстовых данных, разбора пользовательского ввода, чтения данных из файлов и других задач, где нужно разбить строку на составные части по определенному критерию. Это основной инструмент для работы со строчками в Python.
Все строки неизменны, и если мы хотим модифицировать строку, есть только один способ – создать новую строку исходя из исходной. Все методы, которые как-то "модифицируют" строки, действительно возвращают новые строки, никак не меняя оригинальный.'''



'''     
                    **Метод join() 
в Python используется для объединения последовательности строк (например, списка или кортежа) в одну строку с использованием указанного разделителя. Этот метод вызывается на строчном объекте, который служит разделителем:
Синтаксис метода join()'''
string.join(iterable)
'''string – строка разделитель, который будет вставлен между элементами последовательности.
iterable – последовательность, список или кортеж строк, которые нужно объединить.
По существу, метод join(), является обратной операцией к методу split.
Рассмотрим типичный пример'''
list_of_strings = ['Hello', 'world']
result = ' '.join(list_of_strings)
print(result)  # Виведе: 'Hello world'
'''В этом примере список ['Hello', 'world'] объединяется в одну строчку с пробелом как разделителем и на выходе в переменный result мы получим строчку 'Hello world'.

Используем разные разделители, как например ',' - это запятая и пробел.'''
elements = ['earth', 'air', 'fire', 'water']
result = ', '.join(elements)
print(result)  # Виведе: 'earth, air, fire, water'
# Здесь строки из списка elements объединяются с запятой и пробелом в качестве разделителей.

# Якщо потрібно видалити зайві пробіли на початку і в кінці рядка, є спеціальний метод strip:
clean = '   spacious   '.strip()
print(clean) # spacious
'''Вывод будет строка "spacious" без пробелов слева и правая.
У этого метода есть два "братья":
"левый", lstrip, удаляет только пробелы в начале строки;
и "правый", rstrip, удаляет только пробелы в конце строки.

Когда нам нужно заменить некоторую подстроку в строке, мы можем воспользоваться методом replace. Метод replace() в Python используется для замены подстроки на другую подстроку в строке. Этот метод возвращает новую строку, где каждое вхождение указанной подстроки заменено другой подстрокой.'''

'''
              **Метод replace()
             Метод replace() має наступний синтаксис'''
str.replace(old, new, count=-1)
# old – подстрока, которую нужно заменить.
# new – подстрока, на которую нужно заменить.
# count – счетчик максимального количества замен. Если не указано или указано –1, заменяются все вхождения.

'''Рассмотрим пример, который в строке "Hello world" слово "world" заменяет словом "Python".'''
text = "Hello world"
new_text = text.replace("world", "Python")
print(new_text)  # Виведе: 'Hello Python'

'''Если нам нужно ограничение количества замен, то:'''
text = "one fish, two fish, red fish, blue fish"
new_text = text.replace("fish", "bird", 2)
print(new_text)  
# Здесь метод replace() заменяет первые два вхождения слова "fish" на слово "bird".
# one bird, two bird, red fish, blue fish

'''Метод replace() також застосовують для видалення підрядка'''
text = "Hello, world!"
new_text = text.replace(" world", "")
print(new_text) # Hello,!
# У цьому прикладі підрядок " world" видаляється з рядка. Виведення:

'''В общем, метод replace() широко используется для обработки текста в Python.
Но может быть полезным при необходимости:
Устранение ошибок в тексте
Замена специфических символов или слов
Форматирование данных для вывода
Удаление или замена чувствительных данных перед выводом или сохранением
Этот метод также является одним из основных инструментов для работы со строками в Python, позволяя легко и быстро изменять содержимое строк.
Для удаления фиксированной последовательности в начале строки есть метод removeprefix:'''
print('TestHook'.removeprefix('Test')) # Hook
print('TestHook'.removeprefix('Hook')) # TestHook
# Вывод, в первом случае 'Test' является префиксом строки и будет удален, во втором 'Hook' это суффикс строки и удален не будет: Hook TestHook

'''Есть четный метод для удаления последовательности в конце строки, removesuffix:'''
print('TestHook'.removesuffix('Test')) # Hook
print('TestHook'.removesuffix('Hook')) # Test

'''Рассмотрим следующую задачу и используем основные инструменты для работы со строками – методы split() и replace(). У вас есть URL поискового запроса, и ваша задача – добыть и обработать параметры этого запроса. К примеру поисковый запрос "Cat and dog"'''
# <https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>

'''Параметры в URL обычно следуют после символа? и разделены символами &. Каждый параметр состоит из ключа и значения разделенных символом =.
Нам нужно написать код, обрабатывающий URL поискового запроса, чтобы извлечь параметры запроса и преобразовать их в формат, с которым легче работать в Python. При вводе поискового запроса в браузере он формирует URL, где ваш запрос и другие настройки кодируются как ряд параметров. Наш код должен "распаковывать" эти параметры, превращая их в словарь Python, где мы можем легко получить доступ к каждому параметру по его имени.
Так что начнем. Сначала нам нужно получить части запроса по URL:'''
# url_search = "<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>"_, query = url_search.split('?')
print(query) # q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t

'''Переменная url_search – это наш начальный URL. Далее операция url_search.split('?') разделяет URL на две части: к знаку ? и после. Поскольку нас интересует только часть после?, мы используем символ _ для игнорирования части URL до ?. Но получаем переменную query в строке, содержащей необходимые нам параметры запроса.

Далее мы добавим в наш код обработку параметров запроса:'''
url_search = "<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>"
_, query = url_search.split('?')
print(query)

obj_query = {}
for el in query.split('&'):
    key, value = el.split('=')
    obj_query.update({key: value.replace('+', ' ')})
print(obj_query) # q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t {'q': 'Cat and dog', 'ie': 'utf-8', 'oe': 'utf-8', 'aq': 't'}

'''Давайте разбираться, что здесь происходит. Мы создаем пустой словарь obj_query для хранения параметров запроса. Выражение query.split('&') разделяет строку на отдельные параметры по символу & и формирует следующий список ['q=Cat+and+dog', 'ie=utf-8', 'oe=utf-8', 'aq =t']. В середине цикла каждый параметр el содержит ключ и значения, разделенные символом =. Сначала мы разделяем каждый параметр el на ключ и значение key, value=el.split('=').
Выражение obj_query.update({key: value.replace('+', ' ')}) добавляет пару ключ-значения в словарь obj_query. Но мы еще выполняем value.replace('+', ' ') и заменяем символы + на пробелы, поскольку в URL пробелы обычно кодируются как +. После завершения цикла выводится обработанный словарь obj_query, где ключи и значения соответствуют параметрам запроса.
Этот подход часто используется в веб-разработке и обработке данных для работы с информацией, полученной из интернет-запросов.'''
''' 
                        ***Метод isdigit()
Останній метод який ми розглянемо це isdigit(). Він використовується для перевірки, чи складається рядок повністю з цифр. Цей метод повертає True, якщо всі символи в рядку є цифрами та рядок складається принаймні з одного символу, інакше повертає False.'''
number = "12345"
print(number.isdigit())  # Виведе: True

text = "Number123"
print(text.isdigit())  # Виведе: False
# В этом примере isdigit() возвращает True для строки "12345", поскольку он состоит исключительно из цифр. Для строки "Number123" метод возвращает False, поскольку он содержит другие символы, кроме цифр.

'''Можно использовать для проверки, ввел ли пользователь число.'''
user_input = input("Введіть число: ")
if user_input.isdigit():
    print("Це дійсно число!")
else:
    print("Це не число!")
'''Проверка цифровых символов в строке.'''
for char in "Hello 123":
    if char.isdigit():
        print(f"'{char}' - це цифра")
    else:
        print(f"'{char}' - не цифра")

'''Этот код проверяет каждый символ в строке и печатает, является ли этот символ цифрой.
'H' - не цифра
'e' - не цифра
'l' - не цифра
'l' - не цифра
'o' - не цифра
' ' - не цифра
'1' - це цифра
'2' - це цифра
'3' - це цифра
'''

'''
                             ***Translate***
Метод translate() в Python используется для преобразования строк путем замены определенных символов другими символами. Этот метод позволяет указать, какие именно символы следует заменить и на что заменить, используя так называемую "таблицу перевода" - специальный словарь, определяющий отображение замен.

Поэтому, прежде чем использовать translate(), нам нужно создать таблицу перевода. Это можно сделать с помощью метода str.maketrans(), принимающего два аргумента:

Строка символов, которые необходимо заменить.
Строка символов, которые нужно заменить.
Длина обеих строк должна быть одинаковой, поскольку они определяют взаимное соответствие символов.
Рассмотрим пример использования translate():'''
intab = "aeiou"
outtab = "12345"
trantab = str.maketrans(intab, outtab)
str = "This is string example"
print(str.translate(trantab))

'''В этом примере все громкие буквы 'a', 'e', ​​'i', 'o', 'u' в строке заменяются соответственно на числа '1', '2', '3', '4', '5' . Результатом выполнения кода будет строчка "Th3s 3s str3ng 2x1mpl2".

Метод translate() также может использоваться для удаления определенных символов из строки. Для этого передайте в maketrans() третий аргумент – строку символов, которые нужно удалить.'''
intab = "aeiou"
trantab = str.maketrans('', '', intab)
str = "This is string example"
print(str.translate(trantab))

'''Этот пример удаляет все громкие буквы из строки, выводя строку "Ths s strng xmpl" без гласных.
Метод может использоваться для различных задач по обработке текста. Нормализация текста, когда нужно заменить или удалить специфические символы. Операции кодирования и декодирования – создание простых кодировок путем замены символов. Фильтрация текста путем удаления нежелательных символов, например пунктуации или цифр.
Метод является отличным выбором для более сложных задач по обработке и трансформации строк. Рассмотрим пару более сложных задач.
Например, нам нужно разработать программу, которая конвертирует строку, содержащую шестнадцатеричные числа (в качестве отдельных символов), в соответствующий двоичный код.
Программа должна обрабатывать как прописные, так и строчные буквы шестнадцатеричных чисел и превращать каждый символ в его четырехбитное двоичное представление.'''
symbols = "0123456789ABCDEF"
code = [
        '0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
        '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'
        ]

MAP = {}

for s, c in zip(symbols, code):
    MAP[ord(s)] = c
    MAP[ord(s.lower())] = c

result = "34 DF 56 AC".translate(MAP)
print(result)

'''Спочатку ми виконуємо ініціалізацію даних:'''
symbols = "0123456789ABCDEF"
code = [
        '0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
        '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'
        ]
# symbols - рядок, що містить символи, які будуть перетворюватися.
# code - список рядків з двійковим кодом, який відповідає кожному символу в symbols.

'''В данном конкретном случае использование str.maketrans() для создания

таблица перевода не будет такой же эффективной, как вручную созданная таблица перевода. Для создания таблицы мы используем словарь MAP. Для этого мы используем zip(symbols, code), создающий пары символ-двоичный код.
Далее цикл for проходит по этим парам, добавляя в MAP соответствие между Unicode кодом символа с помощью функции ord(s) и его двоичным кодом c. Для каждого символа добавляется как его верхний, так и нижний регистр s.lower().'''
MAP = {}

for s, c in zip(symbols, code):
    MAP[ord(s)] = c
    MAP[ord(s.lower())] = c
{
    48: "0000",
    49: "0001",
    50: "0010",
    51: "0011",
    52: "0100",
    53: "0101",
    54: "0110",
    55: "0111",
    56: "1000",
    57: "1001",
    65: "1010",
    97: "1010",
    66: "1011",
    98: "1011",
    67: "1100",
    99: "1100",
    68: "1101",
    100: "1101",
    69: "1110",
    101: "1110",
    70: "1111",
    102: "1111",
}
'''Де ключ це Unicode для символів "0123456789ABCDEF" в верхньому та нижньому регістрі, а значення відповідні елементи списку code.

☝ Функція ord() в Python - це вбудована функція, яка використовується для отримання Unicode коду символу. Коли ви працюєте з текстом в Python, кожен символ у рядку має відповідний числовий код - Unicode. Функція ord() приймає символ і повертає його Unicode код, який є цілим числом.
Далі ми використовуємо метод translate() для перетворення рядка "34 DF 56 AC" відповідно до нашої таблиці перекладу MAP. Метод кожен символ у вихідному рядку замінює на його двійкове представлення згідно з MAP.'''
result = "34 DF 56 AC".translate(MAP)
print(result) # 00110100 11011111 01010110 10101100
# Коли цей код виконується, він перетворює кожен символ у "34 DF 56 AC" в його відповідник у двійковому коді, використовуючи MAP. Це виведе двійкове представлення кожного шістнадцяткового символу.
 
'''Наступний приклад, це розробити програму, яка перетворює вхідний текстовий рядок на відповідний код мови Морзе.'''
morze_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
              'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
              'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
              'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
              'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
              '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
              '8': '---..', '9': '----.'}

# Перетворення ключів словника на Unicode коди
table_morze_dict = {}
for k, v in morze_dict.items():
    table_morze_dict[ord(k)] = v

string = "Hello world"

result = ""

for ch in string:
    result = result + ch.upper().translate(table_morze_dict)

print(result)
# Словник morze_dict, де ключами є латинські літери та цифри, а значеннями - відповідні коди у мові Морзе. З цього словника нам треба створити таблицю перекладу table_morze_dict, тому цей фрагмент коду відповідає саме за це:
table_morze_dict = {}
for k, v in morze_dict.items():
    table_morze_dict[ord(k)] = v
'''Цикл for проходить по кожному елементу словника morze_dict та для кожного ключа словника morze_dict використовуючи функцію ord(k) додає до словника table_morze_dict Unicode ключі та відповідні коди Морзе - значеннями.
Далі ми перетворюємо рядок string в рядок result але вже азбукою Морзе.''' 
string = "Hello world"

result = ""

for ch in string:
    result = result + ch.upper().translate(table_morze_dict)

print(result) # ......-...-..--- .-----.-..-..-..
'''Ми виконуємо ініціалізацію змінної result для зберігання результату. Після цикл for проходить по кожному символу рядка string. За допомоги методу ch.upper() перетворюємо символ у верхній регістр, щоб відповідати ключам у таблиці table_morze_dict. Метод translate(table_morze_dict) використовується для заміни кожного символу його відповідником у мові Морзе згідно з таблицею table_morze_dict. Результат додається до result.
В кінці виконання коду змінна result містить перетворений рядок у мові Морзе, який виводиться на екран.
Який висновок можна зробити? Метод translate() є потужним інструментом, який пропонує більш гнучкі можливості порівняно з методом replace(), особливо коли вам потрібно зробити багато різних замін у одному рядку.'''

'''
                      ***Форматирование строк
Любое число можно записать несколькими вариантами записи:
десятичная запись
двоичное представление
шестнадцатеричное представление
научная нотация
с фиксированной точностью (числом знаков после запятой)
и другие.
Например, вывести числа от 0 до 7 в десятичном, шестнадцатеричном, восьмеричном и двоичном представлении можно следующим образом:'''
for i in range(8):
    s = f"int: {i:d};  hex: {i:#x};  oct: {i:#o};  bin: {i:#b}"
    print(s)
# int: 0;  hex: 0x0;  oct: 0o0;  bin: 0b0
# int: 1;  hex: 0x1;  oct: 0o1;  bin: 0b1
# int: 2;  hex: 0x2;  oct: 0o2;  bin: 0b10
# int: 3;  hex: 0x3;  oct: 0o3;  bin: 0b11
# int: 4;  hex: 0x4;  oct: 0o4;  bin: 0b100
# int: 5;  hex: 0x5;  oct: 0o5;  bin: 0b101
# int: 6;  hex: 0x6;  oct: 0o6;  bin: 0b110
# int: 7;  hex: 0x7;  oct: 0o7;  bin: 0b111

'''Форматування за допомогою виразів у f-рядках дозволяє не тільки вставляти значення змінних у рядок, а й форматувати ці значення за допомогою спеціальних вказівок.'''
price = 19.99
quantity = 3
total = f"Total: {price * quantity:.2f}"
print(total) # Total: 59.97
# В цьому прикладі використовується форматування :.2f для відображення дійсного числа з двома цифрами після десяткового розділювача

'''У виразі :.2f:

: вводить специфікацію формату.
.2 означає, що після десяткової крапки має бути виведено дві цифри.
f вказує на формат дійсного числа.
Цей формат дуже корисний при виведенні грошових сум, наукових даних, або будь-яких інших чисел, де потрібна точність до певного числа знаків після коми.
Крім того, при створенні рядків буває корисним відформатувати рядок так, щоб знаки на різних рядках були один під одним (додати пробілів), додати заповнення в рядки для того, щоб результат був завжди однієї і тієї самої довжини. Або вивести квадрати та куби чисел до 12 у вигляді таблиці, відцентрувавши значення у стовпцях по 10 символів шириною:'''
width = 5
for num in range(12):
    print(f'{num:^10} {num**2:^10} {num**3:^10}')
'''    0          0          0     
    1          1          1     
    2          4          8     
    3          9          27    
    4          16         64    
    5          25        125    
    6          36        216    
    7          49        343    
    8          64        512    
    9          81        729    
    10        100        1000   
    11        121        1331
Цель работы с метаязычным форматированием состоит в указании в фигурных скобках, каким образом следует превратить значение перед тем как подставить его в строку.

Выравнивание и ширина поля в f-строках Python позволяют контролировать, как текст или числа отображаются в строке, включая выравнивание (слева, справа, по центру) и общую ширину поля, используемой для отображения содержимого. Эти возможности особенно полезны, когда вам нужно создать упорядоченный, аккуратный текстовый вывод.

Ширина поля указывает минимальную ширину поля, в которое будет помещено содержимое. Если содержимое короче ширины поля, оно будет дополнено пробелами.

Выравнивание определяет, как содержимое выравнивается внутри указанной ширины поля. Возможные варианты выравнивания:

<: Выравнивание содержимого по левому краю.
>: Выравнивание содержимого по правому краю.
^: Выравнивание содержимого по центру.
=: используется для выравнивания чисел, при этом знак (если он есть) отображается слева, а число – по правому краю поля.'''
name = "Alice"
formatted = f"{name:>10}"
print(formatted)  # Виведе: '     Alice' (вирівнювання праворуч)
# Виведення з 5-ма пробілами ліворуч
'''☝ Форматування спочатку було зроблено для методу format, який приймає аргументи, як значення для щоб підставити їх в рядок, замість виразів у фігурних дужках.

Також корисним є форматування відсотків за допомогою f-рядків, що дозволяє зручно відображати числа як відсотки. Для цього використовується специфікатор формату %, який множить число на 100 і додає символ відсотка % до рядка. Це особливо корисно при роботі з даними, де потрібно представляти частки або пропорції у форматі відсотків.

Форматування відсотків у f-рядках виглядає так:'''
f"{value:<ширина>.<точність>%}"
'''value - значення, яке потрібно перетворити у відсотки.
<ширина> - загальна ширина поля; необов'язково.
<точність> - кількість знаків після десяткової крапки; необов'язково.
'''
completion = 0.756
formatted = f"{completion:.1%}"
print(formatted)  # Виведе: '75.6%'
# Тут число 0.756 перетворюється на '75.6%', де .1 вказує на вивід однієї цифри після десяткової крапки. Виведення:
# Приклад без десяткових частин:
progress = 0.5
formatted = f"{progress:.0%}"
print(formatted) # 50%
# У цьому випадку число 0.5 перетворюється на '50%', без додаткових десяткових знаків.

'''Регулярные выражения


Регулярные выражения (regular expressions, часто сокращающиеся как regex или regexp) – это мощный инструмент для работы с текстом, позволяющий искать, заменять или извлекать определенные шаблоны в тексте с помощью специального синтаксиса. Регулярные выражения широко используются в программировании, обработке текста, а также различных программах и инструментах для работы с данными.

Основные компоненты регулярных выражений включают в себя:

Литералы. Прямое отображение символов (например, a, B, 1).
Метасимволы. Символы, имеющие особое значение в регулярных выражениях (например, . (точка) соответствует любому символу).
Квантификаторы. Определяют, сколько раз элемент должен соответствовать (например, * означает 0 или более повторений).
Классы символов. Определяют группы символов (например, [a-z] соответствует любой строчной букве).
Группы и диапазоны. Используются для группировки частей выражения (например (abc) определяет группу символов).
Альтернация. Соответствует одному из нескольких шаблонов (например, a|b соответствует a или b).
Якоря. Определяют позиции в тексте (например, ^ для начала строки, $ для конца строки).


Регулярные выражения могут быть достаточно сложными, но они очень мощны для расширенного поиска и обработки текста. Они широко используются во многих языках программирования, а не только в Python.



Регулярные выражения позволяют искать определенные шаблоны в строках, производить замены, разбивать строки на части и многое другое. Для работы с регулярными выражениями в Python используется модуль re.


Основные функции модуля re которые мы рассмотрим далее:

re.search(pattern, string) – выполняет поиск первого вхождения шаблона в строке.
re.findall(pattern, string) – выполняет нахождение всех вхождений шаблона в строке.
re.sub(pattern, repl, string) – выполняет замену вхождений шаблона на другую строку.
re.split(pattern, string) производит разбивание строки по шаблону.

Основная задача регулярных выражений — это поиск строки или подстроки, соответствующей описанию в терминах регулярных выражений.

Используя этот механизм можно делать следующие операции:

проверять, что строка отвечает некоторым требованиям (это номер телефона или email);
разделять строки на подстроки по некоторому выражению (разбить текст на предложение, используя все знаки препинания, а не только какой-то один);
заменять подстроку в строке (заменить все начинающиеся слова на некоторую последовательность);
находить подстроку в строке, соответствующей выражению.


Регулярные выражения находят применение во многих областях, включая обработку текста, валидацию данных, парсинг и скрапинг веб-страниц, поиск и замена в текстовых редакторах и многое другое. Они являются мощным инструментом для любого программиста, работающего с текстовыми данными.

Регулярное выражение или коротко "регулярка" состоит из обычных символов и специальных командных последовательностей. Например, задает любую цифру, а задает любую последовательность из одной или более цифр. Это называется шаблоны регулярных выражений.

Регулярные выражения используют специальные символы для создания шаблонов. Они состоят из блоков и модификаторов.

Примером блока может служить:
\w - любая цифра или буква [a-zA-Z0-9_] (\W - все, кроме буквы или цифры [^a-za-z0-9_])
\d - любая цифра [0-9] (\D - все, кроме цифры [^0-9])
\s — любой пробельный символ [\t\n\r\f\v] (\S — все, кроме пробельных символов [^\t\n\r\f\v])
\b — предел слова
[...] — один из символов в скобках ([^ ] — любой символ, кроме тех, что в скобках)
^ и $ — начало и конец строки соответственно
( ) — группирует выражение и возвращает найденный текст
\t, \n, \r — символ табуляции, новой строки и возвращение каретки


Модификаторы могут указывать на количество повторений блока в выражении, например:
. — один любой символ, кроме строки \n
? - 0 или 1 вхождение шаблона слева
+ — 1 и более вхождений шаблона слева
* — 0 и более вхождений шаблона слева
\ — экранирование спец.символов (пример: \. — означает точку или \+ — знак "плюс")
{n} строго n раз (n целое число)
{n,m} - от n до m вхождений (пример: {,m} - от 0 до m)
a|b - соответствует a или b. Сам символ означает "или" между двумя шаблонами
( ) — группирует выражение и возвращает найденный текст


Каждый элемент позволяет создавать гибкие и мощные шаблоны поиска в тексте с помощью регулярных выражений. Именно составление регулярных выражений — это очень большая тема для отдельного изучения. Но базовые принципы создания регулярных выражений мы с вами разберем.

☝ Вот хорошая статья на тему регулярных выражений, там много примеров и полезных ссылок.
Для работы с регулярными выражениями у Python есть стандартный модуль re. Чтобы воспользоваться этим модулем, его нужно сначала импортировать:

import re
Общим для всех функций модуля re является то, что первым аргументом следует регулярное выражение в виде строки.

----Метод search
Модуль re у Python предоставляет инструменты для работы с регулярными выражениями. Одна из основных функций этого модуля – re.search(), которая используется для поиска первого вхождения шаблона в строке.Регулярное выражение – это шаблон, используемый для нахождения определенных комбинаций символов в строках.
re.search(pattern, string)
pattern: Регулярное выражение (шаблон), которое вы хотите найти.
string: Строка, в которой вы хотите найти шаблон.


Результат выполнения re.search() это специальный объект Match, если находит соответствие. Если соответствие не найдено, возвращает None.

Объект Match обладает свойствами и методами, используемыми для получения информации о поиске и результатах:

Match.span() возвращает кортеж, содержащий начальную и конечную позиции совпадения.
Match.string возвращает строку, передаваемую в функцию,
Match.group() возвращает часть строки, в которой было совпадение


Вы можете использовать метод .group() в этом объекте, чтобы получить соответствующую часть строки.

Тесты 
1. Який метод у Python використовується для заміни входжень патерну у рядку?
re.sub()
2. Яка функція Python використовується для знаходження всіх входжень патерну у рядку?
re.findall()
3. Що символізує символ ^ у регулярних виразах?
Початок рядка
4. Як у Python представити будь-який один символ у регулярному виразі?
.
5. Що робить вираз f"{value:%}" у форматуванні рядків Python?
Конвертує value в відсоток
6. Що робить метод split() у Python?
Розділяє рядок на список підрядків на основі розділювача
7. Які символи в регулярному виразі Python відповідають будь-якій цифрі та будь-якій букві відповідно?
\d та \w
8. Як у регулярних виразах Python позначається група символів, яка може зустрічатися 0 або більше разів?
*
9. У регулярних виразах Python, яка функція використовується для пошуку першого входження шаблону в рядку?
re.search()





'''























































