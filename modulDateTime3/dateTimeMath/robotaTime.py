'''
                                      ***Работа со временем***
Модуль time в Python предоставляет функции для работы с временем, в том числе с временными метками timestamps, паузами выполнения для программы, а также другими временными операциями.
Модуль используется для различных задач, связанных с временем, включая логирование, тайминг операций, создание пауз выполнения программы, обработку временных меток и форматирование времени для отображения пользователям. Является базовым инструментом для работы со временем в Python, хотя он и не включает в себя поддержку временных зон или сложных операций с датами, которые обеспечиваются ранее рассмотренным модулем datetime.
Рассмотрим основные методы модуля time
Метод time.time() возвращает текущее время в секундах с 1 января 1970 (epoch time).'''
import time

current_time = time.time()
print(f"Поточний час: {current_time}") # Поточний час: 1702857932.326853

'''Метод time.sleep(seconds) останавливает выполнение программы на указанное количество секунд. Например, этот код останавливает выполнение программы на 5 секунд.'''
import time

print("Початок паузи")
time.sleep(5)
print("Кінець паузи")

'''Метод time.ctime([seconds]) превращает временную метку (количество секунд) в понятное для человека текстовое представление. Если аргумент не указан, используется текущее время.'''
import time

current_time = time.time()
print(f"Поточний час: {current_time}")

readable_time = time.ctime(current_time)
print(f"Читабельний час: {readable_time}") # Текущее время: 170285823.9412928 Читательное время: Mon Dec 18 02:08:43 2023

'''Метод time.localtime([seconds]) преобразует временную метку в структуру struct_time в местной временной зоне.'''
import time

current_time = time.time()
print(f"Текущее время: {current_time}")

local_time = time.localtime(current_time)
print(f"Местное время: {local_time}")
# Текущее время: 1702861070.8583968
# Местное время: time.struct_time(tm_year=2023, tm_mon=12, tm_mday=18, tm_hour=2, tm_min=57, tm_sec=50, tm_wday=0, tm_yday=352, tm_is

'''Объект time.struct_time в Python является именуемым кортежем, который используется для представления времени.
tm_year – год
tm_mon – месяц от 1 до 12
tm_mday – день месяца от 1 до 31
tm_hour - часы от 0 до 23
tm_min – минуты от 0 до 59
tm_sec – секунды от 0 до 59
tm_wday – день недели от 0 до 6
tm_yday – день года от 1 до 366
tm_isdst – флажок летнего времени. 0 означает, что летнее время не действует, -1 - информация отсутствует, 1 - летнее время действует

Метод time.gmtime([seconds]) похож на localtime, но возвращает struct_time в UTC.
Достаточно важен метод time.perf_counter(), который предоставляет доступ к счетчику с высокой точностью, и является идеальным для измерения коротких интервалов времени.
Этот счетчик имеет высокую доступную точность для измерения коротких временных периодов и используется в основном для определения времени выполнения кода.

Как это работает? Метод time.perf_counter() возвращает значение в секундах (как действительное число) с некоторого момента, например, с момента запуска программы, и это значение монотонно увеличивается. Это означает, что оно может использоваться для точного замера отрезков времени.

Давайте используем time.perf_counter() для измерения времени выполнения некоторого блока кода:'''
import time

# Записываем время в начале выполнения
start_time = time.perf_counter()

# Выполняем какую-то операцию
for _ in range(1_000_000):
 pass # Просто проходит цикл миллион раз

# Записываем время после выполнения операции
end_time = time.perf_counter()

# Рассчитываем и выводим время выполнения
execution_time = end_time – start_time
print(f"Время выполнения: {execution_time} секунд") # Час виконання: 0.04927480001060758 секунд
# В этом примере мы измеряем время, необходимое для прохождения цикла миллион раз. 
# Переменные start_time и end_time измеряют время в начале и конце цикла, соответственно, а разница между ними дает нам общее время выполнения операций цикла.
'''Метод очень полезен для точного измерения времени выполнения кода, особенно в случаях, когда требуется определить производительность или оптимизировать некоторые аспекты программы.

В этом примере мы встретили несколько новых вещей. Первое, что в Python представление чисел с подчеркиваниями _ является способом сделать большие числа более читабельными.'''
# Один миллион
a = 1_000_000
print(a) # Выведет 1000000

# Десять миллионов
b = 10_000_000
print(b) # Выведет 10000000

# Один миллиард
c = 1_000_000_000
print(c) # Выведет 1000000000
'''Подчеркивание в этом контексте просто визуальные разделители, которые помогают легче воспринимать большие числа, но не влияют на их числовую величину или поведение.
Второе, это оператор pass, используемый как заполнитель или "пустая" инструкция. Он не делает ничего и используется там, где синтаксис требует наличия хотя бы одной инструкции, но вам не нужно делать никаких действий.
Другими словами, pass можно использовать для обозначения места в коде, которое может быть заполнено позже. В нашем примере, pass используется внутри цикла for. Это означает, что на каждой итерации цикла выполняется pass, не делающий ничего. Цикл просто проходит миллион итераций, не производя никакого действия на каждой из них.
Есть и другие случаи использования pass например в функциях:'''
def my_function():
    pass
# Здесь pass используется в функции, которая пока не содержит содержимого.
# Оператор pass полезен для временного "заполнения" места в коде, позволяющем вашей программе выполняться, даже когда определенные части еще не были реализованы.
'''
                     ***Ключевые аспекты: основные методы модуля time в Python
time.time(): Возвращает текущее время в секундах с 1 января 1970 (epoch time).
time.sleep(seconds): Остановка выполнения программы на указанное количество секунд.
time.ctime([seconds]): Преобразует временную метку в текстовое представление, понятное для человека.
time.localtime([seconds]): Преобразует временную метку в структуру struct_time в местной временной зоне.
time.gmtime([seconds]): Аналогично localtime, но возвращает struct_time в формате UTC.
time.perf_counter(): Возвращает счетчик с высокой точностью для измерения коротких интервалов времени.'''